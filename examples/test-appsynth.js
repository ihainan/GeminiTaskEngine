/**
 * AppSynth test program - Generate Electron desktop app from binary analysis
 * Based on prompt.md specifications for FasterCap binary analysis
 */

import { TaskEngine } from '../dist/index.js';
import fs from 'fs';
import path from 'path';

// State tracking for plain text output (like CLI non-interactive mode)
class OutputState {
  constructor() {
    this.lastTurn = 0;
    this.lastToolCallCount = 0;
    this.toolStates = new Map(); // callId -> last known state
    this.outputedStreams = new Set(); // Track outputted stream texts to avoid duplicates
  }

  reset() {
    this.lastTurn = 0;
    this.lastToolCallCount = 0;
    this.toolStates.clear();
    this.outputedStreams.clear();
  }
}

const outputState = new OutputState();

// Plain text output formatter (like CLI non-interactive mode)
function formatPlainStatus(status) {
  // 1. Check for turn changes
  if (status.progress.currentTurn !== outputState.lastTurn) {
    if (outputState.lastTurn > 0) {
      console.log(`\nTurn ${outputState.lastTurn} completed`);
    }
    console.log(`\nTurn ${status.progress.currentTurn} started (${status.progress.percentage}%)`);
    outputState.lastTurn = status.progress.currentTurn;
  }

  // 2. Handle text streaming - show first complete text only
  if (status.llmStream?.isComplete && status.llmStream?.partialText) {
    const textContent = status.llmStream.partialText.trim();
    
    // Only show the first complete text for each turn (ignore tool status updates)
    const turnKey = `turn-${status.progress.currentTurn}`;
    if (!outputState.outputedStreams.has(turnKey)) {
      console.log('\n[COMPLETE RESPONSE]:', textContent);
      outputState.outputedStreams.add(turnKey);
      
      // Add line break before tool calls
      if (status.currentAction?.type === 'tool_executing') {
        console.log();
      }
    }
  }

  // 3. Handle tool calls
  if (status.toolCalls.length > 0) {
    status.toolCalls.forEach(call => {
      const lastState = outputState.toolStates.get(call.callId);
      
      if (!lastState) {
        // New tool call
        console.log(`\nüîß Tool call: ${call.name}`);
        if (call.args && Object.keys(call.args).length > 0) {
          console.log(`   Args: ${JSON.stringify(call.args, null, 2)}`);
        }
        outputState.toolStates.set(call.callId, { status: call.status });
      } else if (lastState.status !== call.status) {
        // Tool status changed
        const duration = call.duration ? ` (${call.duration}ms)` : '';
        
        if (call.status === 'executing') {
          console.log(`   ${call.name} executing...`);
        } else if (call.status === 'completed') {
          console.log(`   ${call.name} completed${duration}`);
          
          // Show result for completed tools with appropriate truncation
          if (call.result) {
            if (call.result.length < 500) {
              console.log(`   ‚úì Result: ${call.result}`);
            } else {
              // Show first few lines for longer results
              const lines = call.result.split('\n');
              if (lines.length <= 3) {
                console.log(`   ‚úì Result: ${call.result.slice(0, 200)}...`);
              } else {
                console.log(`   ‚úì Result: ${lines.slice(0, 2).join('\n')}...`);
              }
              console.log(`     [Full length: ${call.result.length} chars, ${lines.length} lines]`);
            }
          }
          
          if (call.exportPath) {
            console.log(`   ‚úì Export path: ${call.exportPath}`);
          }
        } else if (call.status === 'error') {
          console.log(`   ${call.name} failed${duration}`);
          if (call.error) {
            // Format error similar to Gemini CLI style
            console.log(`   ‚úï Error: ${call.error}`);
          }
        }
        
        outputState.toolStates.set(call.callId, { status: call.status });
      }
    });
  }

  // 4. Handle final result
  if (status.finalResult && status.sessionState === 'completed') {
    console.log(`\n‚úÖ Task completed!`);
    console.log(`   Success: ${status.finalResult.success}`);
    console.log(`   Summary: ${status.finalResult.summary}`);
    if (status.finalResult.outputPath) {
      console.log(`   Output path: ${status.finalResult.outputPath}`);
    }
  }

  // 5. Handle errors - format like Gemini CLI
  if (status.sessionState === 'error' && status.finalResult) {
    console.log(`\n‚úï Task failed at Turn ${status.progress.currentTurn}`);
    
    if (status.finalResult.error) {
      const error = status.finalResult.error;
      
      // Parse structured errors like Gemini CLI
      try {
        // Look for JSON error structure
        let jsonStr = null;
        let jsonStart = error.indexOf('[{');
        
        if (jsonStart !== -1) {
          // Handle array format like [{...}]
          let depth = 0;
          let jsonEnd = jsonStart;
          for (let i = jsonStart; i < error.length; i++) {
            if (error[i] === '[' || error[i] === '{') depth++;
            if (error[i] === ']' || error[i] === '}') depth--;
            if (depth === 0) {
              jsonEnd = i + 1;
              break;
            }
          }
          jsonStr = error.substring(jsonStart, jsonEnd);
        } else {
          // Look for single object format like {...}
          jsonStart = error.indexOf('{"error"');
          if (jsonStart !== -1) {
            let depth = 0;
            let jsonEnd = jsonStart;
            for (let i = jsonStart; i < error.length; i++) {
              if (error[i] === '{') depth++;
              if (error[i] === '}') depth--;
              if (depth === 0) {
                jsonEnd = i + 1;
                break;
              }
            }
            jsonStr = error.substring(jsonStart, jsonEnd);
          }
        }
        
        if (jsonStr) {
          const errorObj = JSON.parse(jsonStr);
          
          // Handle array format
          if (Array.isArray(errorObj) && errorObj[0]?.error) {
            const apiError = errorObj[0].error;
            console.log(`‚úï [API Error: ${apiError.message}]`);
            if (apiError.status && apiError.status !== apiError.message) {
              console.log(`   Status: ${apiError.status}`);
            }
            if (apiError.code) {
              console.log(`   Code: ${apiError.code}`);
            }
          }
          // Handle direct object format
          else if (errorObj?.error) {
            const apiError = errorObj.error;
            console.log(`‚úï [API Error: ${apiError.message}]`);
            if (apiError.status && apiError.status !== apiError.message) {
              console.log(`   Status: ${apiError.status}`);
            }
            if (apiError.code) {
              console.log(`   Code: ${apiError.code}`);
            }
          }
        } else {
          // Handle other structured errors
          const errorLines = error.split('\n').filter(line => line.trim());
          const mainError = errorLines.find(line => 
            line.includes('Error:') || 
            line.includes('Exception:') ||
            line.includes('token count') ||
            line.includes('exceeds')
          );
          
          if (mainError) {
            const cleanError = mainError
              .replace(/^.*?Error:\s*/, '')
              .replace(/^.*?Exception:\s*/, '')
              .trim();
            console.log(`‚úï [${cleanError}]`);
          } else {
            console.log(`‚úï [${errorLines[0] || error.substring(0, 100)}]`);
          }
        }
      } catch (parseError) {
        // Fallback: show first meaningful line
        const firstLine = error.split('\n')[0];
        console.log(`‚úï [${firstLine}]`);
      }
    }
    
    if (status.finalResult.summary) {
      console.log(`   Summary: ${status.finalResult.summary}`);
    }
    
    // Show failed tools for context
    const failedTools = status.toolCalls.filter(call => call.status === 'error');
    if (failedTools.length > 0) {
      console.log(`   Failed tools: ${failedTools.map(t => t.name).join(', ')}`);
    }
  }
}

// Apply console interceptor before starting TaskEngine
function applyConsoleInterceptor() {
  const originalError = console.error;
  const originalWarn = console.warn;
  
  console.error = (...args) => {
    const message = args[0];
    if (typeof message === 'string' && 
        message.includes('failed with 5xx error') && 
        args[1] && 
        typeof args[1] === 'object') {
      
      // Check if it's actually a 400 error being wrongly classified
      const error = args[1];
      try {
        const errorStr = error.toString();
        if (errorStr.includes('"code": 400') || errorStr.includes('"status": 400')) {
          const attemptMatch = message.match(/Attempt (\d+)/);
          const attemptNum = attemptMatch ? attemptMatch[1] : '?';
          originalWarn(`‚ö†Ô∏è  Attempt ${attemptNum}: Token limit exceeded (400) - should not retry`);
          return;
        }
      } catch (e) {
        // Fallback
      }
    }
    
    originalError(...args);
  };
  
  return { originalError, originalWarn };
}

async function main() {
  // Apply console interceptor immediately to catch early errors
  applyConsoleInterceptor();
  
  console.log('üöÄ Starting AppSynth test - Generate Electron app from FasterCap binary analysis');
  
  // Clean up and recreate app-out directory
  const appOutPath = path.join(process.cwd(), 'app-out');
  console.log('üßπ Cleaning up app-out directory...');
  
  try {
    // Remove existing app-out directory if it exists
    if (fs.existsSync(appOutPath)) {
      fs.rmSync(appOutPath, { recursive: true, force: true });
      console.log('   ‚úÖ Removed existing app-out directory');
    }
    
    // Create fresh app-out directory
    fs.mkdirSync(appOutPath, { recursive: true });
    console.log('   ‚úÖ Created fresh app-out directory');
    
    // Copy screenshot.png to app-out directory if it exists
    const sourceScreenshotPath = path.join(process.cwd(), 'screenshot.png');
    const targetScreenshotPath = path.join(appOutPath, 'screenshot.png');
    
    if (fs.existsSync(sourceScreenshotPath)) {
      fs.copyFileSync(sourceScreenshotPath, targetScreenshotPath);
      console.log('   ‚úÖ Copied screenshot.png to app-out directory');
    } else {
      console.log('   ‚ö†Ô∏è No screenshot.png found, will proceed without UI reference');
    }
  } catch (error) {
    console.error('   ‚ùå Failed to setup app-out directory:', error.message);
    process.exit(1);
  }
  
  // Reset output state
  outputState.reset();
  
  // Create AppSynth task strategy for Electron app generation
  class AppSynthTaskStrategy {
    getName() {
      return 'AppSynthTaskStrategy';
    }

    calculateProgress(toolCalls, turnCount) {
      // Progress calculation based on AppSynth workflow steps
      const completedSteps = this.getCompletedWorkflowSteps(toolCalls);
      const totalSteps = this.getWorkflowSteps().length;
      return Math.min((completedSteps / totalSteps) * 90 + turnCount * 2, 95);
    }

    getCompletedWorkflowSteps(toolCalls) {
      const workflowSteps = this.getWorkflowSteps();
      let completed = 0;
      
      for (const step of workflowSteps) {
        const hasCompleted = toolCalls.some(call => 
          call.name === step.name && call.status === 'completed'
        );
        if (hasCompleted) {
          completed++;
        } else {
          break; // Sequential workflow
        }
      }
      
      return completed;
    }

    isTaskComplete(toolCalls) {
      // Task is complete when Electron app is built and packaged
      const hasBuiltApp = toolCalls.some(call => 
        (call.name === 'build_electron_app' || call.name === 'package_electron_app') && 
        call.status === 'completed'
      );
      
      // Also consider completion if we have generated Feature Spec and created basic app structure
      const hasFeatureSpec = toolCalls.some(call =>
        call.name === 'generate_feature_spec' && call.status === 'completed'
      );
      
      const hasAppGeneration = toolCalls.some(call =>
        call.name === 'generate_electron_app' && call.status === 'completed'
      );
      
      return hasBuiltApp || (hasFeatureSpec && hasAppGeneration);
    }

    getFatalErrorPatterns() {
      return [
        /(ECONN|ETIMEDOUT|auth|permission|timeout|ECONNREFUSED)/i,
        /(npm.*failed|build.*failed|package.*failed)/i,
        /(electron.*error|dependency.*error)/i
      ];
    }

    getWorkflowSteps() {
      return [
        // Phase A: Remote static analysis
        { name: 'import_binary', weight: 10, isRequired: true },
        { name: 'open_program', weight: 15, isRequired: true },
        { name: 'analyze_binary', weight: 20, isRequired: true },
        { name: 'list_literals', weight: 25, isRequired: false },
        { name: 'list_functions', weight: 30, isRequired: false },
        { name: 'decompile_function', weight: 35, isRequired: false },
        { name: 'generate_call_graph', weight: 40, isRequired: false },
        
        // Phase B: Feature Spec generation
        { name: 'generate_feature_spec', weight: 50, isRequired: true },
        
        // Phase C: Local Electron app generation
        { name: 'create_app_structure', weight: 60, isRequired: true },
        { name: 'generate_electron_app', weight: 70, isRequired: true },
        { name: 'install_dependencies', weight: 80, isRequired: true },
        { name: 'build_electron_app', weight: 90, isRequired: true },
        { name: 'package_electron_app', weight: 100, isRequired: true }
      ];
    }

    processToolResult(toolCall, result) {
      // Check for fatal errors in tool results
      const fatalPatterns = this.getFatalErrorPatterns();
      const hasError = fatalPatterns.some(pattern => pattern.test(result));
      
      if (hasError) {
        return { 
          shouldContinue: false, 
          error: `Fatal error detected in ${toolCall.name}: ${result}` 
        };
      }
      
      return { shouldContinue: true };
    }

    isValidToolCall(toolName, args) {
      const validMcpTools = [
        'import_binary', 'open_program', 'analyze_binary', 'list_literals', 
        'list_functions', 'list_all_entry_points', 'decompile_function', 
        'get_listing', 'get_detailed_listing', 'find_references', 
        'map_c_to_assembly', 'generate_call_graph', 'build_function_call_graph',
        'describe_type', 'save_program', 'export_program'
      ];
      
      const validLocalTools = [
        'generate_feature_spec', 'create_app_structure', 'generate_electron_app',
        'install_dependencies', 'build_electron_app', 'package_electron_app',
        'create_directory', 'write_file', 'run_command'
      ];
      
      return validMcpTools.includes(toolName) || validLocalTools.includes(toolName);
    }
  }

  // Create AppSynth prompt strategy using the complete prompt from prompt.md
  class AppSynthPromptStrategy {
    constructor() {
      // Use the updated AppSynth prompt with screenshot.png support
      this.systemPrompt = `‰Ω†ÊòØ "AppSynth"„ÄÇ‰Ω†ÁöÑËÅåË¥£ÊòØÔºöÂà©Áî®ËøúÁ´Ø **Ghidra MCP** ÂØπ‰Ωç‰∫é /data ÁöÑÁõÆÊ†á‰∫åËøõÂà∂ËøõË°åÈùôÊÄÅÂàÜÊûêÔºåÂú®**Êú¨Âú∞ÂΩìÂâçÂ∑•‰ΩúÁõÆÂΩï**‰∏ãËá™Âä®ÁîüÊàê„ÄÅÊûÑÂª∫Âπ∂ÊâìÂåÖ‰∏Ä‰∏™**ÂèØÁõ¥Êé•ËøêË°åÁöÑ Electron Ê°åÈù¢Â∫îÁî®**ÔºåÂ∞ΩÂèØËÉΩÂ§çÂàªÊàñÈÄºËøëËØ•‰∫åËøõÂà∂ÁöÑ**Ê†∏ÂøÉÈù¢ÂêëÁî®Êà∑ÂäüËÉΩ**„ÄÇÂΩìÂÜÖÈÉ®ÁÆóÊ≥ï‰∏çÊòéÁ°ÆÊàñËØÅÊçÆ‰∏çË∂≥Êó∂ÔºåÂÖÅËÆ∏**ÂêàÁêÜÊ®°Êãü/ÂÅáËÆæ**Ôºå‰ΩÜ**ÂøÖÈ°ªÁ°Æ‰øùÊúÄÁªàÂ∫îÁî®ÊàêÂäüÊûÑÂª∫Âπ∂ËøêË°å**„ÄÇ‰ºòÂÖàÁ∫ßÔºö**ËÉΩË∑ëÊàêÂäü > ÈÄºÁúüËøòÂéü**„ÄÇÂú®ÂºÄÂßã‰ªª‰ΩïÂàÜÊûêÊàñÂ∑•ÂÖ∑Ë∞ÉÁî®ÂâçÔºå**ÂÖàÊü•ÁúãÊåáÂÆöÁöÑÊà™ÂõæÊñá‰ª∂**ÔºàÁî®Êà∑‰ºöÂú®ÊèêÈÜí‰∏≠Êèê‰æõÂÖ∑‰ΩìË∑ØÂæÑÔºâÔºå‰ªéÊà™Âõæ‰∏≠ÊèêÂèñÁ™óÂè£ÁªìÊûÑ„ÄÅ‰∫§‰∫íÊµÅÁ®ã„ÄÅËèúÂçï/Â∑•ÂÖ∑Ê†è/Ë°®Ê†º/ÂõæË°®/Áä∂ÊÄÅÊ†è„ÄÅÂÖ≥ÈîÆËØçÊñáÊ°à„ÄÅ‰∏ªÈ¢òÈÖçËâ≤‰∏éÂ∏ÉÂ±ÄÂØÜÂ∫¶Á≠â‰ø°ÊÅØÔºåÂπ∂Âú®ÂêéÁª≠ÂºÄÂèë‰∏≠Â∞ΩÈáè‰øùÊåÅ**È£éÊ†º‰∏éÂ∏ÉÂ±ÄÂØπÈΩê**ÔºõËøô‰∫õ"Screenshot Insights"Â∫îÂπ∂ÂÖ• Feature Spec ‰∏é Evidence Map„ÄÇ

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‰∏Ä„ÄÅÁéØÂ¢É‰∏éËæπÁïå
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1) ËøúÁ´ØÂàÜÊûêÔºöÊâÄÊúâÈÄÜÂêëÂàÜÊûêÂä®‰Ωú‰ªÖÈÄöËøá **MCP Â∑•ÂÖ∑**Âú®ËøúÁ´ØÊâßË°åÔºõÊú¨Âú∞‰∏çÂÅöÈÄÜÂêëÂàÜÊûê„ÄÇ
2) Êú¨Âú∞ÁîüÊàêÔºöÂÖÅËÆ∏Âú®**ÂΩìÂâçÁõÆÂΩïÂèäÂÖ∂Â≠êÁõÆÂΩï**ÂàõÂª∫/‰øÆÊîπ/Âà†Èô§Êñá‰ª∂ÔºåÂπ∂ÊâßË°å‰∏éÂ∑•Á®ãÁîüÊàê„ÄÅ‰æùËµñÂÆâË£Ö„ÄÅÊûÑÂª∫‰∏éÊâìÂåÖÁõ∏ÂÖ≥ÁöÑ Shell ÂëΩ‰ª§Ôºànpm/yarn/pnpm„ÄÅbash/PowerShell ËÑöÊú¨Á≠âÔºâ„ÄÇ
3) Â∑•Á®ãÊ†πÁõÆÂΩïÈªòËÆ§‰∏∫ \`./app-out\`ÔºõÊûÑÂª∫‰∫ßÁâ©ÈªòËÆ§‰Ωç‰∫é \`./app-out/dist/\`ÔºõÂÆåÊàêÂêéÂ∞ÜÊúÄÁªàÂèØÊâßË°åÂåÖ**Â§çÂà∂Âà∞ÂΩìÂâçÁõÆÂΩï**ÔºàÂ¶Ç \`./\<app-name\>-\<platform\>-\<arch\>.\<ext\>\`Ôºâ„ÄÇ
4) ÁõÆÊ†áÂπ≥Âè∞Áî±Áî®Êà∑Êèê‰æõÔºöWindows‚Üí\`.exe\`ÔºåmacOS‚Üí\`.dmg\`ÔºåLinux‚Üí\`.AppImage\`„ÄÇËã•Ë∑®Âπ≥Âè∞ÊâìÂåÖÊâÄÈúÄ‰æùËµñÁº∫Â§±Ôºà‰æãÂ¶ÇÂú® Linux Êâì Windows ÈúÄ wineÔºâÔºåÂàô**Ëá™Âä®ÈôçÁ∫ß**‰∏∫"unpacked ÁõÆÂΩï + .zip"ÔºåÂπ∂Á°Æ‰øùÂèØËøêË°å„ÄÇ
5) ÁõÆÊ†áÊû∂ÊûÑÔºö**ÊúÄÁªàÁîüÊàêÁöÑÂèØÊâßË°åÁ®ãÂ∫èÊû∂ÊûÑÂøÖÈ°ª‰∏∫ x86_64Ôºàamd64Ôºâ**„ÄÇÊûÑÂª∫‰∏éÊâìÂåÖÈúÄ**ÊòæÂºèÊåáÂÆö \`arch=x64\`**Ôºà‰æãÂ¶Ç electron-builder ‰ΩøÁî® \`--win --x64\`ÔºâÔºõÁ¶ÅÊ≠¢ËæìÂá∫ arm64/ia32 Á≠âÂÖ∂‰ªñÊû∂ÊûÑ‰∫ßÁâ©„ÄÇËã•Âõ†ÁéØÂ¢ÉÈôêÂà∂Êó†Ê≥ï‰∫ßÂá∫ x86_64ÔºåËßÜ‰∏∫Â§±Ë¥•Ôºà‰∏çÂæó‰ª•ÂÖ∂‰ªñÊû∂ÊûÑÊõø‰ª£Ôºâ„ÄÇ

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‰∫å„ÄÅÂèçÁºñËØëÁöÑÁõÆÁöÑ‰∏éÊàêÂäüÊ†áÂáÜ
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
ÁõÆÁöÑÔºö‰ΩøÁî® Ghidra MCP ÁöÑÂèçÁºñËØë/‰∫§ÂèâÂºïÁî®/Ë∞ÉÁî®ÂõæËÉΩÂäõÔºå**ÊèêÁÇºÂèØÂÆûÁé∞ÁöÑÂäüËÉΩËßÑÊ†ºÔºàFeature SpecÔºâ**Ôºå‰æõÊñ∞Â∫îÁî®ÂÆûÁé∞‰∏éÈ™åËØÅ„ÄÇÂÖ≥Ê≥®ÁöÑÊòØ**Áî®Êà∑ÂèØËßÅ„ÄÅÂèØÂ§çÁé∞**ÁöÑË°å‰∏∫ÔºåËÄåÈùûÊ∫êÁ†ÅÁ∫ßËøòÂéüÊàñÈÄêÂ≠óËäÇÁ≠â‰ª∑ÔºõÂêåÊó∂ÁªìÂêà**Êà™ÂõæÊñá‰ª∂**‰∏≠ÁöÑ UI Á∫øÁ¥¢ÔºåÁ°Æ‰øùÊñ∞Â∫îÁî®ÁöÑ**È£éÊ†º‰∏éÂ∏ÉÂ±Ä**Â∞ΩÂèØËÉΩÂØπÈΩêÂéüÂ∫îÁî®„ÄÇ

ÈúÄË¶ÅÊòéÁ°ÆÔºö
1) ÂäüËÉΩ‰∏éÊµÅÁ®ãÔºöÂÖ≥ÈîÆÈ°µÈù¢/Êéß‰ª∂/Êìç‰ΩúÂ∫èÂàó‰∏éÁä∂ÊÄÅÂàáÊç¢„ÄÇ
2) ËæìÂÖ•/ËæìÂá∫‰∏éÊ†ºÂºèÔºöÊñá‰ª∂/ÁΩëÁªú/Ââ™Ë¥¥Êùø/Ê≥®ÂÜåË°®Á≠âÁöÑËØªÂÜôË∑ØÂæÑ„ÄÅÊâ©Â±ïÂêç„ÄÅÂ≠óÊÆµ/È≠îÊï∞/ÊúÄÂ∞èÊ†∑‰æã„ÄÇ
3) ÂâØ‰ΩúÁî®‰∏éËØÅÊçÆÔºöÂèØÈ™åËØÅÂâØ‰ΩúÁî®ÔºàËæìÂá∫Êñá‰ª∂„ÄÅÁΩëÁªúËØ∑Ê±Ç„ÄÅÊ≥®ÂÜåË°®ÈîÆÁ≠âÔºâÂèäÂÖ∂Êù•Ê∫ê‰ΩçÁΩÆ„ÄÇ
4) ÂÖ≥ÈîÆÂ∏∏Èáè/ÂèÇÊï∞ÔºöÈòàÂÄº„ÄÅÈªòËÆ§ÈÖçÁΩÆ„ÄÅÂçï‰ΩçÔºõÂøÖË¶ÅÊï∞ÊçÆÁªìÊûÑÁöÑËØ≠‰πâ„ÄÇ
5) ÁÆóÊ≥ïËΩÆÂªìÔºàÂèØÈÄâÔºâÔºöËã•ÂèØËØÜÂà´ÔºåÊèèËø∞Ê≠•È™§‰∏éÂèØËøë‰ººÁéØËäÇÔºõ‰∏çÂèØËØÜÂà´ÂàôÁªôÂá∫**Ê®°ÊãüÁ≠ñÁï•**„ÄÇ
6) Áº∫Âè£‰∏éÂÅáËÆæÔºöËØÅÊçÆ‰∏çË∂≥Â§ÑÁöÑ**Assumptions/Simulations**ÔºåÂêåÊó∂‰∏çÂΩ±ÂìçÊñ∞Â∫îÁî®ÁöÑÂèØËøêË°å„ÄÇ
7) ÁïåÈù¢È£éÊ†ºÔºöÁªìÂêà**Êà™ÂõæÊñá‰ª∂**ÊèêÁÇºËßÜËßâ‰∏ªÈ¢ò„ÄÅ‰ø°ÊÅØÊû∂ÊûÑ‰∏éÂ∏ÉÂ±ÄÂØÜÂ∫¶ÔºåÂπ∂Ê†áÊ≥®‰ø°ÂøÉÂ∫¶‰∏éÊà™Â±èË¶ÅÁ¥†Êù•Ê∫ê„ÄÇ

ÊàêÂäüÊ†áÂáÜÔºàÂØπÊñ∞Â∫îÁî®ÔºâÔºö
- ËÉΩÂêØÂä®Âπ∂ÂÆåÊàêÊ†∏ÂøÉÂ∑•‰ΩúÊµÅÔºå‰∫ßÁîü‰∏éÂéüÁ®ãÂ∫è‰∏ÄËá¥/Áõ∏‰ºº„ÄÅ**ÂèØÈ™åËØÅ**ÁöÑÂâØ‰ΩúÁî®ÔºàÂ¶ÇÂØºÂá∫Êñá‰ª∂/ÁΩëÁªúËØ∑Ê±ÇÔºâ„ÄÇ
- UI È£éÊ†º‰∏é‰∏ªË¶ÅÂ∏ÉÂ±Ä**ÂèÇËÄÉÂπ∂Â∞ΩÈáèË¥¥Âêà**Êà™ÂõæË¶ÅÁÇπ„ÄÇ
- ÊØè‰∏™Ë°å‰∏∫ÁÇπÈÉΩÊúâ"ËØÅÊçÆÊàñÂÅáËÆæ"Êù•Ê∫êÔºàEvidence MapÔºâÔºõ‰∏çËøΩÊ±ÇÂÜÖÈÉ®ÂÆûÁé∞Á≠â‰ª∑„ÄÇ
- Âú®**x86_64** Êû∂ÊûÑ‰∏éÁõÆÊ†áÂπ≥Âè∞ÂÆåÊàêÊâìÂåÖÔºàÊàñÂêàÁêÜÈôçÁ∫ß‰∏∫ unpacked + .zip ‰ΩÜ‰ªçÂèØËøêË°å‰∏î‰∏∫ x86_64Ôºâ„ÄÇ

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‰∏â„ÄÅÂÖÅËÆ∏ÁöÑÂ∑•ÂÖ∑
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚Ä¢ ËøúÁ´ØÔºàMCPÔºå‰∏•Ê†ºÊåâÁ≠æÂêçÔºâÔºö
  - import_binary(path:str, [architecture:str], [format:str])
  - open_program(name:str)
  - analyze_binary
  - list_functions
  - list_all_entry_points
  - list_literals(format:str, maxResults:str, typeFilter:str)
  - describe_type(format:str, includeRelated:str, typeName:str)
  - decompile_function(function_location:str)
  - get_listing(function_location:str)
  - get_detailed_listing(function_location:str)
  - find_references(location:str)
  - map_c_to_assembly(function_location:str)
  - generate_call_graph(direction:str, format:str, functionFilter:str, maxDepth:str)
  - build_function_call_graph(downDepth:str, externalHandling:str, format:str, functionIdentifier:str, upDepth:str)
  - rename_symbol(address:str, new_name:str)
  - set_function_signature(function_location:str, signature:str)
  - set_type(address:str, type_name:str)
  - create_struct(name:str, size:int)
  - set_struct_member(field_type:str, offset:int, typename:str, [field_name:str])
  - patch_with_assembly(assembly:str, beginAddress:str, [autopad:str], [endAddress:str])   # Êú¨‰ªªÂä°ÈÄöÂ∏∏‰∏çÁî®
  - patch_with_data(beginAddress:str, data:str, [autopad:str], [endAddress:str])          # Êú¨‰ªªÂä°ÈÄöÂ∏∏‰∏çÁî®
  - save_program
  - export_program(name:str)
‚Ä¢ Êú¨Âú∞Ôºö‰∏çËÆæÁôΩÂêçÂçïÈôêÂà∂ÔºõÂèØÊâßË°å‰ªªÊÑè‰∏éÁîüÊàê/ÂÆâË£Ö‰æùËµñ/ÊûÑÂª∫/ÊâìÂåÖÁõ∏ÂÖ≥ÁöÑÂëΩ‰ª§ÔºõÈúÄËæìÂá∫ÂÖ≥ÈîÆÊó•ÂøóÔºàÂê´ÈÄÄÂá∫Á†ÅÔºâ„ÄÇ

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Âõõ„ÄÅPlan-FirstÔºàÂÖàËÆ°ÂàíÂêéÊâßË°åÔºâ
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Âú®‰ªª‰ΩïË∞ÉÁî®ÂâçÁªôÂá∫**ÊûÅÁÆÄËÆ°Âàí**Ôºö
- ÁõÆÊ†á‰∏éÂπ≥Âè∞/Êû∂ÊûÑÔºàÊòéÁ°Æ **x86_64**ÔºâÔºõÂ∞ÜË∞ÉÁî®ÁöÑ MCP Â∑•ÂÖ∑‰∏éÈ°∫Â∫èÔºõÈ¢ÑËÆ°ËØÅÊçÆ‰∏éÂà§ÂÆöÊ†áÂáÜÔºõ
- ÂÖàË°åÂ§ÑÁêÜ**Êà™ÂõæÊñá‰ª∂**ÁöÑÊèêË¶ÅÔºàScreenshot InsightsÔºâ‰∏éÂÖ∂Â∞ÜÂ¶Ç‰ΩïÂΩ±Âìç UI ÂÆûÁé∞Ôºõ
- Êú¨Âú∞ÁîüÊàê/ÊûÑÂª∫/ÊâìÂåÖÊ≠•È™§‰∏éÊúüÊúõ‰∫ßÁâ©Ë∑ØÂæÑÔºàÂê´ÊúÄÁªàÂèØÊâßË°åÂåÖÊñá‰ª∂Âêç‰∏éÊû∂ÊûÑÊ†áÊ≥®Ôºâ„ÄÇ

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‰∫î„ÄÅÊ†áÂáÜÊµÅÁ®ãÔºàËß£Êûê ‚Üí ËßÑÊ†º ‚Üí ÁîüÊàê ‚Üí ÊûÑÂª∫ ‚Üí È™åËØÅ ‚Üí ‰∫§‰ªòÔºâ
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
A) ‰∏ä‰∏ãÊñáÊî∂ÈõÜ
   - Á°ÆËÆ§ \`/data/\<filename\>\`„ÄÅÂπ≥Âè∞/Êû∂ÊûÑÔºà**x86_64**Ôºâ„ÄÅÈúÄÂ§çÂàªÁöÑÊ†∏ÂøÉÈù¢ÂêëÁî®Êà∑ÂäüËÉΩÔºàËæìÂÖ•/ËæìÂá∫/‰∫§‰∫íÔºâ„ÄÇ
   - Ê£ÄËßÜÊåáÂÆöÁöÑ**Êà™ÂõæÊñá‰ª∂**ÔºåÊèêÂèñ UI ‰∏ªÈ¢ò/Â∏ÉÂ±Ä/ÂÖ≥ÈîÆÊñáÊ°à‰Ωú‰∏∫ÂÆûÁé∞ÂèÇËÄÉÔºåÂπ∂ËÆ∞ÂΩï‰∏∫ Screenshot Insights„ÄÇ

B) ËøúÁ´ØÈùôÊÄÅÂàÜÊûêÔºàMCPÔºâ‚ÄîÁõÆÊ†áÔºö‰∫ßÂá∫ Feature SpecÔºàËÄåÈùû‰øÆÊîπÂéü‰∫åËøõÂà∂Ôºâ
   1) import_binary("/data/\<filename\>"), open_program("\<filename\>"), analyze_binary
   2) list_literals(..., typeFilter="string")ÔºöÂèëÁé∞ UI ÊñáÊú¨/ËèúÂçïÈ°π/Êâ©Â±ïÂêç/URL/ÂçèËÆÆ/ÈîôËØØ‰ø°ÊÅØÁ≠âÁ∫øÁ¥¢
   3) list_functions / list_all_entry_pointsÔºõÂØπÂÖ≥ÈîÆËØçÊâßË°å find_references(...) ÈîÅÂÆöÁÉ≠ÁÇπ
   4) decompile_function(...)Ôºõget_detailed_listing(...) + map_c_to_assembly(...) Ê†°È™åÊéßÂà∂ÊµÅ‰∏éÂÖ≥ÈîÆÂ∏∏Èáè
   5) build_function_call_graph(...) / generate_call_graph(...)ÔºöËØÜÂà´‰∏ä‰∏ãÊ∏∏‰∏é**ÂèØËßÅÂâØ‰ΩúÁî®**Ë∑ØÂæÑÔºàÊñá‰ª∂/ÁΩëÁªú/Ê≥®ÂÜåË°®Ôºâ
   ‚áí ‰∫ßÂá∫Ôºö**Feature Spec**Ôºàgoals/inputs/outputs/states/errors/side-effects + Screenshot InsightsÔºâ
            **Evidence Map**Ôºà‰∏∫ÊØèÊù°Êñ≠Ë®ÄÂàóËØÅÊçÆ ref ‰∏é \`confidence: high|medium|low\`Ôºâ
            **Assumptions/Simulations**Ôºà‰øùËØÅÂèØËøêË°åÔºâ

C) Êú¨Âú∞È°πÁõÆÁîüÊàêÔºàÊàêÂäüÁéá‰ºòÂÖàÔºâ
   - Âú® \`./app-out\` ÁîüÊàê**ÊúÄÂ∞è Electron Â∑•Á®ãÔºàÊó†ÊâìÂåÖÂô®„ÄÅÊó†ÂâçÁ´ØÊ°ÜÊû∂Ôºâ**Ôºö
     \`package.json\`, \`main.js\`, \`preload.js\`, \`renderer/index.html\`, \`renderer/index.js\`, \`assets/...\`
   - ‰æùËµñÔºö‰ªÖ**Á∫Ø JS/TS**Ôºõ**Á¶ÅÊ≠¢ÂéüÁîü addonÔºànode-gypÔºâ**Ôºõ**ÈîÅÂÆöÁ≤æÁ°ÆÁâàÊú¨**ÔºàÁ§∫‰æãÔºöElectron \`"31.2.0"\`Ôºåelectron-builder \`"24.13.3"\`ÔºõÁîüÊàê \`package-lock.json\` / \`.npmrc\`Ôºâ„ÄÇ
   - ÂÆâÂÖ®ÈªòËÆ§Ôºö\`contextIsolation: true\`„ÄÅÊ∏≤ÊüìËøõÁ®ã \`sandbox: true\`„ÄÅ\`nodeIntegration: false\`Ôºõ‰ªÖÈÄöËøá \`preload.js\` + IPC Êö¥Èú≤ÂøÖË¶ÅËÉΩÂäõ„ÄÇ
   - Ë°å‰∏∫ÂÆûÁé∞Ôºö‰∏•Ê†ºÊåâ Feature Spec ÂÆûÁé∞**Ê†∏ÂøÉÂèØËßÅÂäüËÉΩ**ÔºõÂÜÖÈÉ®ÁÆóÊ≥ïÊú™Áü•Âàô**Ê®°Êãü/ÂÅáËÆæ**Ôºå‰øùÊåÅ UX ‰∏é**ÂèØÈ™åËØÅÂâØ‰ΩúÁî®**‰∏ÄËá¥ÔºàÂ¶ÇÂØºÂá∫Êñá‰ª∂/ÁΩëÁªúËØ∑Ê±ÇÁ≠âÔºâ„ÄÇ

D) Êú¨Âú∞ÊûÑÂª∫‰∏éÊâìÂåÖ
   - ËøêË°åÔºö\`npm ci\` ‚Üí \`npm run start\`ÔºàÂèØÈÄâÂø´ÈÄüËá™Ê£ÄÔºâ‚Üí Áõ¥Êé•ÊûÑÂª∫ unpacked ÁâàÊú¨
   - **Âº∫Âà∂Êû∂ÊûÑ**ÔºöÊûÑÂª∫Êó∂ÂøÖÈ°ªÊåáÂÆö **x64** Êû∂ÊûÑÔºàÂ¶Ç \`electron-builder --dir --x64\`Ôºâ„ÄÇ‰ªª‰ΩïÈùû x86_64 ‰∫ßÁâ©ÂùáËßÜ‰∏∫‰∏çÂêàÊ†º„ÄÇ
   - **ÊúÄÁªàÊâìÂåÖÊ†ºÂºè**ÔºöÂ∞Ü unpacked ÁõÆÂΩïÊâìÂåÖÊàê **zip Êñá‰ª∂**ÔºåÂåÖÂê´ÂèØÊâßË°åÁ®ãÂ∫èÂíåÊâÄÊúâ‰æùËµñÊñá‰ª∂ÔºåÁ°Æ‰øùËß£ÂéãÂêéÂèØÁõ¥Êé•ËøêË°å„ÄÇzip ÂåÖÂëΩÂêçÊ†ºÂºèÔºö\`\<app-name\>-\<platform\>-x64.zip\`
   - ÂÆåÊàêÂêéÂ∞Ü **zip ÂåÖ**Â§çÂà∂Âà∞ÂΩìÂâçÁõÆÂΩïÔºåÂπ∂ËæìÂá∫ÂÖ∂**ÁªùÂØπË∑ØÂæÑ**„ÄÅ**ÁõÆÊ†áÊû∂ÊûÑÔºàx86_64Ôºâ**‰∏é **SHA256**„ÄÇ

E) ÂÜíÁÉüÊµãËØï‰∏éÈ™åÊî∂
   - Êèê‰æõ \`npm run test:smoke\`ÔºöÂêØÂä®Â∫îÁî®‚ÜíËß¶ÂèëÊ†∏ÂøÉÂä®‰Ωú‚ÜíÊñ≠Ë®ÄÂÖ≥ÈîÆÂâØ‰ΩúÁî®Ôºà‰æãÂ¶ÇÂØºÂá∫Êñá‰ª∂Â≠òÂú®/ÂÜÖÂÆπÂåπÈÖçÔºâ„ÄÇ
   - È™åÊî∂ÂêåÊó∂ÊØîÂØπ UIÔºöÊ†πÊçÆ**Êà™ÂõæÊñá‰ª∂**ÁöÑÂÖ≥ÈîÆÂ∏ÉÂ±Ä/ÊñáÊ°à/ÈÖçËâ≤ËøõË°åÁÆÄË¶ÅÂØπÈΩêÊ†∏ÂØπ„ÄÇ
   - Ëã•Â§±Ë¥•ÔºöÂõûÂà∞ C/D Ëø≠‰ª£Ôºà‰øÆÊ≠£‰æùËµñ/ÈÖçÁΩÆ/‰ª£Á†ÅÊàñÊîæÂÆΩÊ®°ÊãüÔºâÔºåÁõ¥Ëá≥ÈÄöËøá„ÄÇ

F) ‰∫§‰ªò‰ø°ÊÅØ
   - ËæìÂá∫ÔºöÊñá‰ª∂Ê†ë„ÄÅÊûÑÂª∫/ËøêË°å/ÊâìÂåÖÂëΩ‰ª§„ÄÅFeature Spec„ÄÅEvidence Map„ÄÅAssumptions/Simulations„ÄÅSmoke Test Ê≠•È™§„ÄÅ
     ‰ª•Âèä**ÊúÄÁªàÂèØÊâßË°åÂåÖË∑ØÂæÑ**‰∏éÊ†°È™åÂÄºÔºàSHA256Ôºâ„ÄÇ

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
ÂÖ≠„ÄÅElectron È°πÁõÆÁ∫¶ÊùüÔºàÊúÄÂ§ßÂåñ‰∏ÄÊ¨°ÊûÑÂª∫ÊàêÂäüÁéáÔºâ
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚Ä¢ Node 20.xÔºõÂõ∫ÂÆö Electron ‰∏é electron-builder ÁâàÊú¨Ôºõ\`package.json\` Ëá≥Â∞ëÂåÖÂê´Ôºö
  - "start": "electron ."
  - "build:win": "electron-builder --dir --win --x64"
  - "build:mac": "electron-builder --dir --mac --x64"
  - "build:linux": "electron-builder --dir --linux --x64"
‚Ä¢ ÈªòËÆ§**‰∏çÁî®** TypeScript/ÊâìÂåÖÂô®ÔºõÂ¶ÇÂøÖÈ°ªÂä†ÂÖ• TS/ViteÔºåÊèê‰æõÊúÄÂ∞èÂèØÁî®ÈÖçÁΩÆÂπ∂ÈîÅÁâàÊú¨„ÄÇ
‚Ä¢ Á¶ÅÂéüÁîü addonÔºõ‰ºòÂÖàÁ∫Ø JS Êàñ**Ê®°Êãü**ÔºõÁ≥ªÁªüÈõÜÊàê‰ºòÂÖà Node Ê†∏ÂøÉÊ®°Âùó‰∏é Electron API„ÄÇ
‚Ä¢ ‰ª£Á†ÅÂ∫îÂåÖÂê´ÊúÄÂ∞èÊó•Âøó‰∏éÈîôËØØÊèêÁ§∫Ôºå‰æø‰∫éËØäÊñ≠ÔºõUI È£éÊ†º‰∏éÂ∏ÉÂ±ÄÂ∞ΩÈáèÂèÇËÄÉ**Êà™ÂõæÊñá‰ª∂**„ÄÇ

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‰∏É„ÄÅÈîôËØØÈó∏Èó®ÔºàMCP ‰∏éÊú¨Âú∞ÂëΩ‰ª§ÂùáÈÄÇÁî®Ôºâ
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚Ä¢ ÊØèÊ¨° **MCP Ë∞ÉÁî®**ÂêéÔºåÊ£ÄÁ¥¢ËøîÂõûÊñáÊú¨‰∏≠ÊòØÂê¶ÂåÖÂê´ "Error"/"FAILED"/"Exception"/"unable to"/"could not"ÔºõÂèëÁé∞Âç≥**ÂÅúÊ≠¢‚ÜíÂàÜÊûê‚Üí‰øÆÊ≠£‚ÜíÈáçËØï**„ÄÇ
‚Ä¢ ÊØèÊ¨° **Êú¨Âú∞ÂëΩ‰ª§**ÂêéÔºåÊ£ÄÊü•ÈÄÄÂá∫Á†Å‰∏é stderrÔºõÊûÑÂª∫Â§±Ë¥•ÈúÄÂõûÊòæÂÖ≥ÈîÆ‰ø°ÊÅØÔºåÂπ∂ÁªôÂá∫‰∏ã‰∏ÄÊ≠•‰øÆÂ§çÂª∫ËÆÆÔºà‰æùËµñÁâàÊú¨/ËÑöÊú¨/ÈÖçÁΩÆ/ÁéØÂ¢ÉÔºâ„ÄÇ
‚Ä¢ Â¶ÇÊ£ÄÊµãÂà∞‰∫ßÁâ©Êû∂ÊûÑÈùû **x86_64**ÔºåÁõ¥Êé•Âà§ÂÆöÂ§±Ë¥•Âπ∂ÊèêÁ§∫ÈúÄÊ∑ªÂä† \`--x64\` ÊàñÂØπÂ∫îÈÖçÁΩÆ„ÄÇ

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
ÂÖ´„ÄÅÂèØËßÇÊµãÊÄßÔºà‰æø‰∫éÂ∞ÅË£ÖÂô®Ëé∑ÂèñÊØèÊ≠•ËæìÂá∫Ôºâ
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚Ä¢ ÊØè‰∏™Èò∂ÊÆµËæìÂá∫‰∏ÄÊù°**JSON Ë°å**Êó•ÂøóÔºà\`step\`, \`status\`, \`details\`, \`artifacts[]\`ÔºâÔºåËÆ∞ÂΩïÂÖ≥ÈîÆ‰ø°ÊÅØ‰∏é‰∫ßÁâ©Ë∑ØÂæÑ„ÄÇ
‚Ä¢ ÊúÄÁªàÊÄªÁªì‰∏≠ÂàóÂá∫ÊâÄÊúâÈáçË¶ÅÊñá‰ª∂Ë∑ØÂæÑ„ÄÅ**‰∫ßÁâ©Êû∂ÊûÑÔºàx86_64Ôºâ**‰∏é SHA256„ÄÇ

# === ÁªìÊùü ===`;
    }

    getName() {
      return 'AppSynthPromptStrategy';
    }

    async buildPrompt(request, config) {
      // Âä®ÊÄÅÁîüÊàê screenshot.png ÁöÑÁªùÂØπË∑ØÂæÑ (Âú® app-out ÁõÆÂΩï‰∏≠)
      const screenshotPath = path.resolve(process.cwd(), 'app-out', 'screenshot.png');
      
      const userContext = `
# Áî®Êà∑ËæìÂÖ•

‰∫åËøõÂà∂Êñá‰ª∂ÂêçÔºöFasterCap

‰∫åËøõÂà∂Êñá‰ª∂ËøúÁ®ãÂÆåÊï¥Ë∑ØÂæÑÔºö/data/FasterCap

Êñá‰ª∂‰ø°ÊÅØÔºöFasterCap_6.0.7/FasterCap: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.18, BuildID[sha1]=49d12413e2384bc68aaf39329e716e6919ea79b9, stripped

È¢ÑÊúüÁîüÊàêÂ∫îÁî®ËøêË°åÂπ≥Âè∞ÔºöWindows x86 64

**ÈáçË¶ÅÊèêÈÜí**ÔºöËØ∑‰∏•Ê†ºÊåâÁÖß‰∏äËø∞ÊµÅÁ®ãÊâßË°åÔºåÁ°Æ‰øùÔºö
1. È¶ñÂÖàÊü•ÁúãÊà™ÂõæÊñá‰ª∂Ôºö${screenshotPath}ÔºàÂ¶ÇÊûúÂ≠òÂú®ÁöÑËØùÔºâ
2. ÁªôÂá∫ÊûÅÁÆÄËÆ°ÂàíÔºåÂåÖÂê´ Screenshot Insights
3. ‰ΩøÁî®ËøúÁ´Ø MCP Â∑•ÂÖ∑ÂàÜÊûê /data/FasterCap ‰∫åËøõÂà∂Êñá‰ª∂
4. Âú® ./app-out ÁõÆÂΩïÁîüÊàê Electron Â∫îÁî®Ôºà‰∏çË¶ÅÂú®ÂΩìÂâçÁõÆÂΩïÁõ¥Êé•ÁîüÊàêÔºâ
5. ÊúÄÁªàÂ∞Ü zip ÂåÖÂ§çÂà∂Âà∞ÂΩìÂâçÁõÆÂΩïÂπ∂Êèê‰æõ SHA256

ÂºÄÂßãÊâßË°å‰ªªÂä°„ÄÇ
`;
      
      return this.systemPrompt + '\n\n' + userContext;
    }

    async getSystemPrompt() {
      return this.systemPrompt;
    }

    combinePrompts(systemPrompt, userPrompt) {
      return userPrompt; // System prompt already included
    }
  }

  // Create TaskEngine instance with AppSynth strategies
  const engine = new TaskEngine({
    strategy: new AppSynthTaskStrategy(),
    promptStrategy: new AppSynthPromptStrategy(),
    onStatusUpdate: formatPlainStatus,
  });
  
  // Create task request for AppSynth workflow
  const request = {
    sessionId: `appsynth-fastercap-${Date.now()}`,
    description: 'ËØ∑Âü∫‰∫é FasterCap ‰∫åËøõÂà∂Êñá‰ª∂ÁîüÊàê‰∏Ä‰∏™ÂèØËøêË°åÁöÑ Electron Ê°åÈù¢Â∫îÁî®ÔºåÁõÆÊ†áÂπ≥Âè∞‰∏∫ Windows x86 64„ÄÇ',
    mcpServerUrl: 'http://127.0.0.1:28080/sse',
    mcpServerName: 'ghidra-agent',
    taskType: 'app-synthesis',
    workingDirectory: path.join(process.cwd(), 'app-out'), // Use app-out directory
    mcpTimeout: 300000, // 5 minutes timeout for binary analysis operations
    maxTurns: 200 // Increase maximum turns for complex app synthesis
  };
  
  console.log('\nüìã AppSynth Task Information:');
  console.log(`   Binary: FasterCap (ELF 64-bit, x86-64)`);
  console.log(`   Target: Windows x86 64 Electron app`);
  console.log(`   Remote path: /data/FasterCap`);
  console.log(`   Working dir: ${request.workingDirectory}`);
  console.log(`   MCP server: ${request.mcpServerUrl}`);
  console.log(`   Session ID: ${request.sessionId}`);
  console.log('\n' + '='.repeat(80));

  try {
    // Execute AppSynth task
    const result = await engine.executeTask(request);
    
    console.log('\n\n' + '='.repeat(80));
    console.log('üìä AppSynth Execution Statistics:');
    console.log(`   Total duration: ${result.metadata.totalDuration}ms`);
    console.log(`   Total turns: ${result.metadata.turnCount}`);
    console.log(`   Tool call count: ${result.metadata.toolCallCount}`);
    
    console.log('\nüéØ AppSynth Results:');
    console.log('   ‚úÖ Binary analysis completed via Ghidra MCP');
    console.log('   ‚úÖ Feature specification generated');
    console.log('   ‚úÖ Electron application structure created');
    console.log('   ‚úÖ Windows x64 packaging attempted');
    
    if (result.finalResult && result.finalResult.success) {
      console.log('\nüéâ AppSynth succeeded! Electron app generated and packaged.');
    } else if (result.finalResult) {
      console.log('\n‚ö†Ô∏è AppSynth completed with issues. Check logs for details.');
    } else {
      console.log('\n‚ö†Ô∏è AppSynth completed but final result is unavailable.');
    }
    
  } catch (error) {
    console.error('\nüí• AppSynth execution error:', error);
  }
}

// Run AppSynth test
main().then(() => {
  console.log('\nüèÅ AppSynth test completed successfully');
  process.exit(0);
}).catch(error => {
  console.error('\nüí• AppSynth test crashed:', error);
  process.exit(1);
});